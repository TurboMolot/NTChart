//// Created by denis on 29.11.17.//#ifndef NTCHART_NTCHART_H#define NTCHART_NTCHART_H#include <vector>#include <utility>#include <algorithm>#include <atomic>class Point {public:    float getX() const {        return x;    }    void setX(float x) {        this->x = x;    }private:    float x;};class Point2D : public Point {public:    Point2D() {        this->skip = 1;    }    Point2D(float x, float y) : y(y) {        setX(x);    }    float getY() const {        return y;    }    void setY(float y) {        this->y = y;    }    void setXY(float x, float y) {        setX(x);        setY(y);    }    bool isSkip() {        return this->skip;    }    void setSkip(bool skip) {        this->skip = skip;    }    bool operator==(const Point2D &pt) const {        return pt.getX() == getX() && pt.getY() == getY();    };    bool operator!=(const Point2D &pt) const {        return pt.getX() != getX() || pt.getY() != getY();    };private:    float y;    bool skip;};template<typename TPointValue, typename std::enable_if<std::is_base_of<Point, TPointValue>::value>::type * = nullptr>using TPoint = TPointValue;template<typename TPoint>long getXIdxBefore(const TPoint *points, std::size_t from, std::size_t to, const float xVal);template<typename TPoint>long getXIdxBefore(const TPoint *points, std::size_t size, const float xVal);template<typename TPoint>long getXIdxBefore(const std::vector<TPoint> points, const float xVal);template<typename TPoint>class Series {public:    void addPoint(TPoint point) {        data.push_back(point);    }    void addPoints(TPoint points[], std::size_t cnt) {        if (points != nullptr && cnt >                                 0) { // TODO: требование! данные должны быть упорядочены по X и первое значение x должно быть больше последнего в существующем массиве            data.insert(data.end(), points, points + cnt);            dataChanged.store(true);//            data.insert(data.end(), points, points + (sizeof(points) / sizeof(points[0])));//            data.insert(data.end(), points);        }    }    const std::vector<TPoint> getData() {        return data;    }    void clearData() {        data.clear();    }    void setRenderSize(float width, float height) {        this->rWidth = width;        this->rHeight = height;    }    virtual void calculateRender() = 0;    virtual std::vector<TPoint> getDataRender() const = 0;protected:    std::vector<TPoint> data;    /**     * Render width     */    float rWidth;    /**     * Render height     */    float rHeight;    float scaleX;    float scaleY;    float offsetX;    float offsetY;    std::atomic_bool dataChanged;};template<typename TPoint>struct FrameRender {    std::vector<TPoint> points;    Point2D renderXMin;    Point2D renderXMax;    Point2D renderYMin;    Point2D renderYMax;    float scaleX;    float scaleY;};class SeriesLine : public Series<Point2D> {public:    SeriesLine();    virtual void calculateRender() override final;    virtual std::vector<Point2D> getDataRender() const override final;protected:    FrameRender<Point2D> frameRender;    float rangeX;    float rangeY;    /**     * Масштабирование установлено пользователем     */    bool useScaleUser;    size_t idxFromLast;    void searchMinMaxRender(FrameRender<Point2D> &frameRender);};//template<typename TPoint, typename std::enable_if<std::is_base_of<Point, TPoint>::value>::type * = nullptr>//using TPointValue = TPoint;////template<typename TPoint, typename std::enable_if<std::is_base_of<Point, TPoint>::value>::type * = nullptr>//class PointVector : public std::vector<TPoint> {//};//////template<typename TPoint, typename std::enable_if<std::is_base_of<Point, TPoint>::value>::type * = nullptr>//class Series {//public://    void addPoint(TPoint);//    void addPoints(TPoint []);//    void removePoint(TPoint);//    void removePoints(TPoint []);//    void clearPoint();////    virtual void calcRender() = 0;//protected://    PointVector<TPoint> data;//    PointVector<TPoint> points;//};////class SeriesLine : public Series<Point2D> {//public://    void calcRender() override;////};////class ntChart {//public://private:////};#endif //NTCHART_NTCHART_H