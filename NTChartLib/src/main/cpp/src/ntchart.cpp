//// Created by denis on 29.11.17.//#include "../inc/ntchart.h"#include <algorithm> // For std::minmax_element#include <tuple> // For std::tie#include <vector> // For std::vector#include <iterator> // For global begin() and end()#include <ctime>//#include "../jni_log.h"#include <iostream>#include <chrono>//using namespace std;//template <class C>//size_t countOf(C const & c) {//    return c.size();//}////void Series::addPoint(TPointVal point) {//    if(point != nullptr)//        data.push_back(point);//}////void Series::addPoints(TPointVal points []) {//    if(points != nullptr) {//        size_t size = countOf<TPointVal>(points);//        if(size > 0) {//            data.push_back(points);//        }//    }//}////void Series::removePoint(TPointVal point) {////}////void Series::removePoints(TPointVal points []) {////}////void Series::clearPoint() {////}//template<typename TimeT = std::chrono::milliseconds>//struct measure//{//    template<typename F, typename ...Args>//    static typename TimeT::rep execution(F&& func, Args&&... args)//    {//        auto start = std::chrono::steady_clock::now();//        std::forward<decltype(func)>(func)(std::forward<Args>(args)...);//        auto duration = std::chrono::duration_cast< TimeT>//                (std::chrono::steady_clock::now() - start);//        return duration.count();//    }//};long min(long val1, long val2) {    return val1 < val2 ? val1 : val2;}template<typename TPoint>long getXIdxBefore(const TPoint *points, std::size_t from, std::size_t to, const float xVal) {    if (points == nullptr || from > to || xVal < points[0].getX())        return -1;    if (xVal > points[to].getX())        return to;    long low = 0, high = to + 1, mid = -1;    while (low < high) {        mid = (low + high) >> 1;        if (xVal == points[mid].getX()) {            // idx = mid; // Точное совпадение            break;        } else {            if (xVal < points[mid].getX()) {                high = mid;            } else {                low = mid + 1;            }        }    }    return (mid < 0 || (xVal <= points[mid].getX()) ? mid : min(mid + 1, to)) - 1;}template<typename TPoint>long getXIdxBefore(const TPoint *points, std::size_t size, const float xVal) {    return getXIdxBefore<TPoint>(points, 0, size - 1, xVal);}template<typename TPoint>long getXIdxBefore(const std::vector<TPoint> points, const float xVal) {    return getXIdxBefore<TPoint>(points.data(), 0, points.size() - 1, xVal);}SeriesLine::SeriesLine() {    useScaleUser = false;    rangeX = (float) M_PI * 400.f;}inline Point2DabsAndScale(FrameRender<Point2D> &frameRender, const Point2D &itm, float xOffset, float yOffset) {    Point2D ret = Point2D();    ret.setXY((itm.getX() + xOffset) * frameRender.scaleX,              (itm.getY() + yOffset) * frameRender.scaleY);    return ret;}inline long getIdx(const std::vector<Point2D> &pts, const Point2D & itmPoint) {    auto it = std::find(pts.begin(), pts.end(), itmPoint);    if (it == pts.end()) {        return -1;    }    return std::distance(pts.begin(), it);}void reducePoints(FrameRender<Point2D> &frameRender) {    if (frameRender.points.empty() || frameRender.points.size() < 2)        return;    float xOffset = frameRender.renderXMin.getX() < 0.0f ? fabsf(frameRender.renderXMin.getX())                                                      : -frameRender.renderXMin.getX();    float yOffset = frameRender.renderYMin.getY() < 0.0f ? fabsf(frameRender.renderYMin.getY())                                                      : 0.0f; //-frameRender.renderYMin.getY()    auto pts = frameRender.points;//    std::vector<Point2D> pts = std::vector<Point2D>();    size_t sizePts = pts.size();//    float tolerance = fminf(//            fabsf(frameRender.renderXMax.getX() - frameRender.renderXMin.getX()) / width,//            fabsf(frameRender.renderYMax.getY() - frameRender.renderYMin.getY()) / height);    float tolerance = fminf(frameRender.scaleX, frameRender.scaleY);    if(tolerance != 0.0f) {        tolerance = 1.0f / tolerance;    } else {        tolerance = 1.0f;    }//    float tolerance = 0.001; // TODO    // Сохраним начало и конец    pts[0].setSkip(0);    pts[sizePts - 1].setSkip(0);//    ptsRet.push_back(absAndScale(frameRender, pts[0], xOffset, yOffset));    // Переменные цикла    size_t anchor = 0;    size_t floater = sizePts - 1;    float anchorX, anchorY, segLen;    Point2D a, f, ptsTmp;    std::vector<size_t> stack((unsigned) sizePts);    stack.clear();//    sizePts = 2;    stack.push_back(anchor);    stack.push_back(floater);    while (!stack.empty()) {        // Инициализация отрезка        floater = stack.back();        stack.pop_back();        anchor = stack.back();        stack.pop_back();        f = pts[floater];        a = pts[anchor];        if (f != a) {            anchorX = f.getX() - a.getX();            anchorY = f.getY() - a.getY();            segLen = sqrtf((anchorX * anchorX) + (anchorY * anchorY));            anchorX /= segLen;            anchorY /= segLen;        } else {            anchorX = anchorY = 0;//            segLen = 0;        }        // Внутренний цикл:        float maxDist = 0;        size_t farthest = anchor + 1;        size_t i = farthest - 1;        while (++i < floater) {            ptsTmp = pts[i];            float distToSeg = 0;            float vecX = ptsTmp.getX() - a.getX();            float vecY = ptsTmp.getY() - a.getY();//            segLen = sqrt(vecX * vecX + vecY * vecY);            float proj = vecX * anchorX + vecY * anchorY;            if (proj >= 0) {                vecX = ptsTmp.getX() - f.getX();                vecY = ptsTmp.getY() - f.getY();                segLen = sqrtf((vecX * vecX) + (vecY * vecY));                proj = vecX * (-anchorX) + vecY * (-anchorY);                if (proj < 0)                    distToSeg = segLen;                else // расстояние от до прямой по теореме Пифагора:                    distToSeg = sqrtf(fabsf(segLen * segLen - proj * proj));                if (maxDist < distToSeg) {                    maxDist = distToSeg;                    farthest = i;                }            }        }        if (maxDist <= tolerance) {            if (pts[anchor].isSkip()) {                pts[anchor].setSkip(0);//                sizePts++;            }            if (pts[floater].isSkip()) {                pts[floater].setSkip(0);//                sizePts++;            }        } else {            stack.push_back(anchor);            stack.push_back(farthest);            stack.push_back(farthest);            stack.push_back(floater);        }    }    std::vector<Point2D> ptsRet = std::vector<Point2D>();    for (auto itm : pts) {        if (!itm.isSkip())            ptsRet.push_back(absAndScale(frameRender, itm, xOffset, yOffset));    }    frameRender.points = ptsRet;}inline void reduceAbsAndScaleRender(FrameRender<Point2D> &frameRender, float width) {    if (frameRender.points.empty())        return;    float xOffset = frameRender.renderXMin.getX() < 0 ? fabsf(frameRender.renderXMin.getX())                                                      : -frameRender.renderXMin.getX();    float yOffset = frameRender.renderYMin.getY() < 0 ? fabsf(frameRender.renderYMin.getY())                                                      : 0; //-frameRender.renderYMin.getY()    const Point2D *points = frameRender.points.data();    const size_t sz = frameRender.points.size();    size_t ptWnd = (size_t) roundf((float) frameRender.points.size() / width);    std::vector<Point2D> ptsRet = std::vector<Point2D>();    if (ptWnd <= 1) {        for (auto &itm : frameRender.points) {            ptsRet.push_back(absAndScale(frameRender, itm, xOffset, yOffset));        }    } else {        size_t idx = 0;        size_t nextWnd = ptWnd;        while (idx < sz) {            Point2D ptMin = points[idx];            Point2D ptMax = ptMin;            while (idx < nextWnd && idx < sz) {                Point2D ptCur = points[idx];                if (ptMin.getY() > ptCur.getY()) {                    ptMin = ptCur;                } else if (ptMax.getY() < ptCur.getY()) {                    ptMax = ptCur;                }                idx++;            }            nextWnd += ptWnd;            if (ptMin == ptMax) {                ptsRet.push_back(absAndScale(frameRender, ptMax, xOffset, yOffset));            } else if (ptMin.getX() < ptMax.getY()) {                ptsRet.push_back(absAndScale(frameRender, ptMin, xOffset, yOffset));                ptsRet.push_back(absAndScale(frameRender, ptMax, xOffset, yOffset));            } else {                ptsRet.push_back(absAndScale(frameRender, ptMax, xOffset, yOffset));                ptsRet.push_back(absAndScale(frameRender, ptMin, xOffset, yOffset));            }        }    }    frameRender.points = ptsRet;}void SeriesLine::searchMinMaxRender(FrameRender<Point2D> &frameRender) {    if (frameRender.points.empty())        return;    frameRender.renderXMin = frameRender.points[0];    frameRender.renderXMax = frameRender.points[frameRender.points.size() - 1];    decltype(frameRender.points)::iterator minEl, maxEl;    std::tie(minEl, maxEl) = std::minmax_element(begin(frameRender.points),                                                 end(frameRender.points),                                                 [](Point2D const &s1, Point2D const &s2) {                                                     return s1.getY() < s2.getY();                                                 });    frameRender.renderYMin = *minEl;    frameRender.renderYMax = *maxEl;}void SeriesLine::calculateRender() {    if (!dataChanged) {        return;    } else {        dataChanged.store(false);    }    FrameRender<Point2D> frame = FrameRender<Point2D>();    std::vector<Point2D> points = getData();    if (points.empty()) {        frameRender = frame;        return;    }//    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();    long idxFrom = 0;    long idxTo = 0;    if (rangeX > 0) {        const Point2D *ptsRaw = points.data() + idxFromLast;        size_t ptsRawSize = points.size() - idxFromLast;        idxFrom = getXIdxBefore<Point2D>(ptsRaw, ptsRawSize, offsetX);        idxTo = getXIdxBefore<Point2D>(ptsRaw, ptsRawSize, offsetX + rangeX);    } else {        idxTo = points.size() - 1;    }    if (idxFrom > 0 && idxFrom >= points.size()) {        idxFrom = points.size() - 1;    } else if (idxFrom < 0) {        idxFrom = 0;    }    if (idxTo > 0 && idxTo >= points.size()) {        idxTo = points.size() - 1;    } else if (idxTo < 0)        idxTo = 0;    if (rangeX > 0) {        offsetX =                (fabsf(points[points.size() - 1].getX() - points[idxFrom].getX()) - rangeX) > 0.0f ?                points[points.size() - 1].getX() - rangeX : 0.0f;//        idxFromLast = (size_t) idxFrom;    }    float xValRange = fabsf(points[idxTo].getX() - points[idxFrom].getX());    frame.scaleX = rWidth / (rangeX > 0 ? rangeX : xValRange);    frame.points = std::vector<Point2D>(points.begin() + idxFrom, points.begin() + idxTo);    searchMinMaxRender(frame);    frame.scaleY = rHeight / fabsf(frame.renderYMax.getY() - frame.renderYMin.getY());//    reducePoints(frame);    reduceAbsAndScaleRender(frame, rWidth);//    absAndScaleRender(frame);//    reduceRenderPoints(frame, rWidth);    frameRender = frame;////    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();//    long time = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();//    std::cout << "Time difference = " << time << std::endl;}std::vector<Point2D> SeriesLine::getDataRender() const {    return frameRender.points;}